// ============================================
// FUNÃ‡Ã•ES DE VALIDAÃ‡ÃƒO - CFOP E NATUREZA
// ============================================

/**
 * Lista de CFOPs vÃ¡lidos para processamento
 * Apenas notas com estes CFOPs serÃ£o processadas
 */
const CFOPS_VALIDOS = [
  5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108,
  6100, 6101, 6102, 6103, 6104, 6105, 6106, 6107, 6108,
  5400, 5401, 5402, 5403, 5404, 5405
];

/**
 * Palavras-chave PERMITIDAS na natureza da operaÃ§Ã£o
 */
const NATUREZA_PERMITIDA = [
  'REVENDA',
  'VENDA',
  'REVENDA DE MERCADORIA',
  'REVENDA MERCADORIA',
  'VENDA MERCADORIA',
  'VENDA DE MERCADORIA'
];

/**
 * Palavras-chave PROIBIDAS na natureza da operaÃ§Ã£o
 */
const NATUREZA_PROIBIDA = [
  'TRANSFERENCIA',
  'TRANSFERÃŠNCIA',
  'BONIFICACAO',
  'BONIFICAÃ‡ÃƒO',
  'BONIFICACÃƒO',
  'BONIFICAÃ‡AO',
  'DEVOLUÃ‡ÃƒO',
  'DEVOLUCAO',
  'DEVOLUÃ‡AO',
  'DEVOLUCÃƒO',
  'DEV',
  'DEVOL',
  'PERDA',
  'PERDAS',
  'OUTRAS',
  'OUTRAS SAÃDAS',
  'OUTRAS SAIDAS',
  'REMESSA',
  'REM',
  'COMPRA',
  'COMPRAS'
];

/**
 * Normaliza texto removendo acentos, convertendo para maiÃºsculas
 * e removendo espaÃ§os extras
 */
function normalizarTexto(texto) {
  if (!texto) return '';
  
  return String(texto)
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove acentos
    .toUpperCase()
    .trim()
    .replace(/\s+/g, ' '); // Remove espaÃ§os mÃºltiplos
}

/**
 * Valida se o CFOP estÃ¡ na lista de CFOPs vÃ¡lidos
 * @param {string|number} cfop - CFOP a ser validado
 * @returns {Object} - { valido: boolean, erro: string, cfop: string }
 */
function validarCFOP(cfop) {
  if (!cfop) {
    return { 
      valido: false, 
      erro: 'CFOP nÃ£o informado',
      cfop: null
    };
  }

  // Limpar e converter para nÃºmero
  const cfopLimpo = String(cfop).replace(/\D/g, '');
  
  if (cfopLimpo.length !== 4) {
    return { 
      valido: false, 
      erro: 'CFOP deve ter 4 dÃ­gitos',
      cfop: cfopLimpo
    };
  }

  const cfopNum = parseInt(cfopLimpo, 10);
  
  // Verificar se estÃ¡ na lista de CFOPs vÃ¡lidos
  if (!CFOPS_VALIDOS.includes(cfopNum)) {
    return { 
      valido: false, 
      erro: `CFOP ${cfopLimpo} nÃ£o estÃ¡ na lista de CFOPs vÃ¡lidos para processamento (vendas). Esta nota serÃ¡ rejeitada.`,
      cfop: cfopLimpo,
      aviso: 'Este CFOP nÃ£o refere-se a uma nota fiscal de venda'
    };
  }

  return { 
    valido: true, 
    cfop: cfopLimpo 
  };
}

/**
 * Valida se a natureza da operaÃ§Ã£o Ã© permitida
 * @param {string} natureza - Natureza da operaÃ§Ã£o a ser validada
 * @returns {Object} - { valido: boolean, erro: string, natureza: string }
 */
function validarNaturezaOperacao(natureza) {
  if (!natureza || typeof natureza !== 'string') {
    return { 
      valido: false, 
      erro: 'Natureza da operaÃ§Ã£o nÃ£o informada',
      natureza: null
    };
  }

  const naturezaNormalizada = normalizarTexto(natureza);
  
  // 1. VERIFICAR SE CONTÃ‰M PALAVRAS PROIBIDAS
  for (const palavraProibida of NATUREZA_PROIBIDA) {
    const palavraProibidaNormalizada = normalizarTexto(palavraProibida);
    
    if (naturezaNormalizada.includes(palavraProibidaNormalizada)) {
      return {
        valido: false,
        erro: `Natureza da operaÃ§Ã£o "${natureza}" contÃ©m termo proibido: "${palavraProibida}". Esta nota nÃ£o refere-se a uma venda e serÃ¡ rejeitada.`,
        natureza: natureza,
        termoProibido: palavraProibida
      };
    }
  }
  
  // 2. VERIFICAR SE CONTÃ‰M PALAVRAS PERMITIDAS
  let contemPalavraPermitida = false;
  let palavraEncontrada = null;
  
  for (const palavraPermitida of NATUREZA_PERMITIDA) {
    const palavraPermitidaNormalizada = normalizarTexto(palavraPermitida);
    
    if (naturezaNormalizada.includes(palavraPermitidaNormalizada)) {
      contemPalavraPermitida = true;
      palavraEncontrada = palavraPermitida;
      break;
    }
  }
  
  if (!contemPalavraPermitida) {
    return {
      valido: false,
      erro: `Natureza da operaÃ§Ã£o "${natureza}" nÃ£o contÃ©m termos vÃ¡lidos para venda (REVENDA, VENDA, etc). Esta nota serÃ¡ rejeitada.`,
      natureza: natureza,
      aviso: 'Natureza da operaÃ§Ã£o nÃ£o indica uma operaÃ§Ã£o de venda vÃ¡lida'
    };
  }
  
  // 3. VALIDAÃ‡ÃƒO ADICIONAL: verificar se contÃ©m palavras-chave de venda
  const palavrasChaveVenda = ['VENDA', 'REVENDA'];
  const temPalavraVenda = palavrasChaveVenda.some(palavra => 
    naturezaNormalizada.includes(normalizarTexto(palavra))
  );
  
  if (!temPalavraVenda) {
    return {
      valido: false,
      erro: `Natureza da operaÃ§Ã£o "${natureza}" nÃ£o caracteriza uma operaÃ§Ã£o de venda vÃ¡lida.`,
      natureza: natureza
    };
  }

  return { 
    valido: true, 
    natureza: natureza,
    palavraEncontrada: palavraEncontrada
  };
}

/**
 * Valida se a nota fiscal pode ser processada
 * Verifica CFOP E Natureza da OperaÃ§Ã£o
 * @param {Object} campos - Campos extraÃ­dos da nota fiscal
 * @returns {Object} - { podeProcessar: boolean, motivo: string, detalhes: Object }
 */
function podeProcessarNota(campos) {
  const resultado = {
    podeProcessar: false,
    motivo: '',
    detalhes: {
      cfop: null,
      natureza: null,
      validacoes: []
    }
  };

  // 1. Validar CFOP
  const validacaoCFOP = validarCFOP(campos.cfop);
  resultado.detalhes.cfop = validacaoCFOP;
  
  if (!validacaoCFOP.valido) {
    resultado.detalhes.validacoes.push({
      campo: 'CFOP',
      valido: false,
      erro: validacaoCFOP.erro,
      valor: campos.cfop
    });
  }

  // 2. Validar Natureza da OperaÃ§Ã£o
  const validacaoNatureza = validarNaturezaOperacao(campos.naturezaOperacao);
  resultado.detalhes.natureza = validacaoNatureza;
  
  if (!validacaoNatureza.valido) {
    resultado.detalhes.validacoes.push({
      campo: 'Natureza da OperaÃ§Ã£o',
      valido: false,
      erro: validacaoNatureza.erro,
      valor: campos.naturezaOperacao
    });
  }

  // 3. Determinar se pode processar (CFOP vÃ¡lido OU Natureza vÃ¡lida)
  const cfopValido = validacaoCFOP.valido;
  const naturezaValida = validacaoNatureza.valido;

  if (cfopValido || naturezaValida) {
    resultado.podeProcessar = true;
    resultado.motivo = 'Nota fiscal validada com sucesso';
    
    if (cfopValido && naturezaValida) {
      resultado.motivo += ' (CFOP e Natureza da OperaÃ§Ã£o vÃ¡lidos)';
    } else if (cfopValido) {
      resultado.motivo += ' (CFOP vÃ¡lido)';
      // Adicionar aviso sobre natureza
      if (!naturezaValida) {
        resultado.detalhes.avisos = resultado.detalhes.avisos || [];
        resultado.detalhes.avisos.push('Natureza da OperaÃ§Ã£o nÃ£o estÃ¡ no formato padrÃ£o, mas CFOP Ã© vÃ¡lido');
      }
    } else if (naturezaValida) {
      resultado.motivo += ' (Natureza da OperaÃ§Ã£o vÃ¡lida)';
      // Adicionar aviso sobre CFOP
      if (!cfopValido) {
        resultado.detalhes.avisos = resultado.detalhes.avisos || [];
        resultado.detalhes.avisos.push('CFOP nÃ£o estÃ¡ na lista padrÃ£o, mas Natureza da OperaÃ§Ã£o Ã© vÃ¡lida');
      }
    }
  } else {
    resultado.podeProcessar = false;
    
    // Montar mensagem de erro detalhada
    const erros = [];
    
    if (!cfopValido) {
      erros.push(`CFOP: ${validacaoCFOP.erro}`);
    }
    
    if (!naturezaValida) {
      erros.push(`Natureza: ${validacaoNatureza.erro}`);
    }
    
    resultado.motivo = `Nota fiscal REJEITADA. ${erros.join(' | ')}`;
  }

  return resultado;
}

// ============================================
// INTEGRAÃ‡ÃƒO COM PROCESSAMENTO DE NOTAS
// ============================================

/**
 * Processa uma nota fiscal individual
 * Extrai campos, valida e registra no sistema
 */
async function processarNotaFiscal(texto, pdfBytes, numeroNF) {
  try {
    // 1. Extrair campos da nota
    const campos = extrairCamposNota(texto);
    
    console.log(`\nðŸ“‹ Processando NF ${numeroNF}`);
    console.log(`CFOP: ${campos.cfop}`);
    console.log(`Natureza: ${campos.naturezaOperacao}`);
    
    // 2. Validar se pode processar
    const validacao = podeProcessarNota(campos);
    
    console.log(`ValidaÃ§Ã£o: ${validacao.motivo}`);
    
    if (!validacao.podeProcessar) {
      console.log(`âŒ NF ${numeroNF} REJEITADA`);
      
      return {
        sucesso: false,
        numeroNF: numeroNF,
        motivo: validacao.motivo,
        detalhes: validacao.detalhes,
        validacoes: validacao.detalhes.validacoes
      };
    }
    
    console.log(`âœ… NF ${numeroNF} APROVADA para processamento`);
    
    // 3. Prosseguir com registro no banco de dados
    // ... (seu cÃ³digo existente de registro)
    
    return {
      sucesso: true,
      numeroNF: numeroNF,
      motivo: validacao.motivo,
      campos: campos,
      validacao: validacao
    };
    
  } catch (error) {
    console.error(`Erro ao processar NF ${numeroNF}:`, error);
    return {
      sucesso: false,
      numeroNF: numeroNF,
      motivo: `Erro no processamento: ${error.message}`,
      erro: error
    };
  }
}

// ============================================
// EXEMPLO DE USO NO ENDPOINT /processar
// ============================================

app.post('/processar', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Nenhum arquivo enviado.' });
    }
    
    const pdfBytes = req.file.buffer;
    const pdfDoc = await PDFDocument.load(pdfBytes);
    const numPages = pdfDoc.getPageCount();

    const resultados = {
      totalNotas: 0,
      aprovadas: 0,
      rejeitadas: 0,
      detalhes: [],
      validacoes: []
    };

    // Extrair e agrupar pÃ¡ginas por NF
    const paginasPorNF = {};
    const textosPorNF = {};
    
    for (let i = 0; i < numPages; i++) {
      const tempPdf = await PDFDocument.create();
      const [pagina] = await tempPdf.copyPages(pdfDoc, [i]);
      tempPdf.addPage(pagina);
      const tempPdfBytes = await tempPdf.save();
      const tempData = await pdfParse(tempPdfBytes);
      const texto = tempData.text;
      const numeroNF = extrairNumeroNF(texto) || `SEMNF_${i+1}`;
      
      if (!paginasPorNF[numeroNF]) {
        paginasPorNF[numeroNF] = [];
        textosPorNF[numeroNF] = [];
      }
      paginasPorNF[numeroNF].push(i);
      textosPorNF[numeroNF].push(texto);
    }

    // Processar cada nota
    for (const numeroNF in paginasPorNF) {
      resultados.totalNotas++;
      
      const resultado = await processarNotaFiscal(
        textosPorNF[numeroNF][0],
        pdfBytes,
        numeroNF
      );
      
      if (resultado.sucesso) {
        resultados.aprovadas++;
        resultados.detalhes.push({
          numeroNF: numeroNF,
          status: 'APROVADA',
          mensagem: resultado.motivo
        });
      } else {
        resultados.rejeitadas++;
        resultados.detalhes.push({
          numeroNF: numeroNF,
          status: 'REJEITADA',
          mensagem: resultado.motivo,
          validacoes: resultado.validacoes
        });
        
        // Adicionar Ã  lista de validaÃ§Ãµes para o relatÃ³rio
        if (resultado.validacoes && resultado.validacoes.length > 0) {
          resultados.validacoes.push(...resultado.validacoes.map(v => ({
            numeroNF: numeroNF,
            ...v
          })));
        }
      }
    }

    // Retornar resposta
    res.json({
      message: 'Processamento concluÃ­do',
      resumo: {
        total: resultados.totalNotas,
        aprovadas: resultados.aprovadas,
        rejeitadas: resultados.rejeitadas,
        taxaAprovacao: resultados.totalNotas > 0 
          ? Math.round((resultados.aprovadas / resultados.totalNotas) * 100) 
          : 0
      },
      detalhes: resultados.detalhes,
      validacoes: resultados.validacoes.length > 0 ? resultados.validacoes : undefined
    });

  } catch (error) {
    console.error('Erro no processamento:', error);
    res.status(500).json({ 
      error: 'Erro interno do servidor',
      details: error.message 
    });
  }
});

// ============================================
// EXPORTAR FUNÃ‡Ã•ES PARA TESTES
// ============================================

module.exports = {
  CFOPS_VALIDOS,
  NATUREZA_PERMITIDA,
  NATUREZA_PROIBIDA,
  normalizarTexto,
  validarCFOP,
  validarNaturezaOperacao,
  podeProcessarNota,
  processarNotaFiscal
};